# 预处理、动态库、静态库

## 1、C语言编译过程

1：**预编译**（预处理）

​       将**.c**中的头文件展开、宏展开

​       生成的文件是**.i**文件

2：**编译**

​       将预处理之后的 **.i** 文件生成 **.s** 汇编文件

3：**汇编**

​       将 **.s** 汇编文件生成 **.o** 目标文件

4：**链接**

​       将 **.o** 文件链接成目标文件

## 2、include

```c
#include<>
//用尖括号包含头文件，在系统指定的路径下找头文件
#include""
//用双引号包含头文件，先在当前目录下找头文件，找不到，再到系统指定的路径下找
```

PS:预处理只是对include等预处理操作进行处理并不会进行语法检查；这个阶段有语法错误也不会报错，第二个阶段编译阶段才会进行语法检查。

## 3、define

定义宏用define去定义

宏是在预编译的时候进行替换。

* **不带参宏**

```c
#define PI 3.14
//在预编译的时候如果代码中出现了PI就用3.14去替换。
```

**宏的好处**：只要修改宏定义，其他地方在预编译的时候会重新替换

PS：宏定义后边不要加分号。

宏定义的作用范围，从定义的地方到本文件末尾。

```c
//如果想在中间终止宏的定义范围
#undef PI//终止PI的作用
```

* **带参宏**

```c
#define S(a,b) a*b
//注意带参宏的形参a和b没有类型名，S（2，4）将来在预处理的时候替换成 实参替代成字符串的形参，，其他字符保留。
int main()
{
    int num;
    num=S(2,4);//num=2*4=8
    num=S(1+3,5);//num=1+3*5=16
    
    return 0;
}
```



* **带参宏和带参函数的区别**

  * 带参宏，被调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，不需要压栈弹栈。所以带参宏，是浪费了空间，因为被展开多次，节省时间。
  * 带参函数，代码只有一份， 存在代码段，调用的时候去代码段取指令，调用的时候要，压栈弹栈。有个调用的过程。带参函数是浪费了时间，节省了空间。

  带参函数的形参是有类型的，带参宏的形参没有类型名。

## 4、选择性编译

**1、**

```c
#ifdef AAA
   代码一
#else
   代码二
#endif
//如果在当前.c文件中ifdef上边宏定义过AAA，就编译代码一，否则编译代码代码二
```

PS:**注意和if else语句的区别，if else语句都会被编译，通过条件选择性执行代码，而选择性编译，只有一块代码被编译。**

**2、**

```c
#ifndef AAA
    代码一
#else 
    代码二
#endif
//和第一种互补。这种方法经常用在防止头文件重复包含。
```

**防止头文件重复包含方法：**

```c
#ifndef __FUN_H__
#define __FUN_H__
extern int fun(int x,int y);//代码块
#endif
```

**3、**

```c
#if 表达式
     代码一
#else 
     代码二
#endif
//如果表达式为真，编译第一段代码，否则编译第二段代码；
//选择性编译都是在预编译阶段干的事。
```

## 5、静态库、动态库

一：**动态编译（耗费时间）**

动态编译使用的是动态库文件进行编译

**gcc    hello.c   -c  hello**

默认的咱们使用的是动态编译方法

二：**静态编译（耗费空间）**

静态编译使用的是静态库文件进行编译

**gcc  -static  hello.c  -o  hello**

三：静态库和动态库编译的区别

1：使用的库文件格式不一样

​       动态编译使用动态库，静态库编译使用静态库

注意：

1：**静态编译要把静态库文件打包编译到可执行程序中**

2：**动态编译不会把动态库文件打包编译到可执行程序中，**

**它只是编译链接关系**